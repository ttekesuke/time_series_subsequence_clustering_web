var server = Server(\nrt,
    options: ServerOptions.new
    .numOutputBusChannels_(2)
    .numInputBusChannels_(2)
    .sampleRate_(44100)
);

a = Score([
  [0.0, ['/d_recv',
    SynthDef(\polySynth, {
        |out=0, freq=440, dur=0.25, amp=0.5, pan=0,
         brightness=0.5, hardness=0.5, texture=0.0, resonance=0.2|

        var sig, env, core, sub;
        var attackTime, releaseTime, cutoff, rq, feedback, pulseWidth, noiseSig;

        // 1) Hardness -> Envelope
        attackTime = (1.0 - hardness).linexp(0.0, 1.0, 0.001, 0.2).min(dur * 0.5);
        releaseTime = dur * (1.0 + (resonance * 2.0));
        env = EnvGen.ar(Env.perc(attackTime, releaseTime, 1.0, -4), doneAction: 2);

        // 2) Texture -> Waveform
        feedback = texture.linlin(0.0, 1.0, 0.0, 2.5);
        core = SinOscFB.ar(freq, feedback);

        pulseWidth = 0.5 + (texture * 0.4);
        core = core * (1.0 - (texture * 0.5)) + (Pulse.ar(freq, pulseWidth) * (texture * 0.5));

        noiseSig = PinkNoise.ar() * (texture - 0.7).max(0) * 0.5;
        sub = SinOsc.ar(freq) * (1.0 - texture).max(0.2) * 0.5;
        sig = core + noiseSig + sub;

        // 3) Brightness -> Filter
        cutoff = freq * (1 + (brightness * 20));
        cutoff = cutoff.clip(20, 20000);

        // 4) Resonance -> Filter Q
        rq = (1.0 - (resonance * 0.95)).clip(0.02, 1.0);

        sig = RLPF.ar(sig, cutoff, rq);
        sig = BHiShelf.ar(sig, 3000, 1.0, (brightness - 0.5) * 12);

        sig = sig * env * amp;
        sig = sig.tanh;

        Out.ar(out, Pan2.ar(sig, pan));
    }).asBytes;
  ]],

  <%
    current_time = 0.0
    node_id = 1000

    # time_series: [step][stream] = [oct, note, vol, bri, hrd, tex]
    # note_chords_pitch_classes: [step][stream] = [pc...]
    time_series.each_with_index do |step_streams, step_idx|
      step_streams = step_streams || []
  %>
    <% step_streams.each_with_index do |s, stream_idx| %>
      <%
        oct  = s[0].to_i
        note = s[1]
        vol  = s[2].to_f
        bri  = s[3].to_f
        hrd  = s[4].to_f
        tex  = s[5].to_f

        next unless vol > 0.01

        # ★ここが重要：
        # サーバ側で note_chords_pitch_classes があればそれを使う。
        # 無い/空なら time_series の note(root) を [root] 扱いにする。
        pcs = note_chords_pitch_classes.dig(step_idx, stream_idx)
        p "pcs"
        p pcs
        pcs = Array(pcs).compact.map { |x| x.to_i } if pcs
        if pcs.nil? || pcs.empty?
          root_pc =
            if note.is_a?(Array)
              note.first.to_i % 12
            else
              note.to_i % 12
            end
          pcs = [root_pc]
        end

        # base midi はあなたの表示と合わせて (oct+1)*12
        base_midi = (oct + 1) * 12

        chord_size = [pcs.size, 1].max
        amp_each = (vol * 0.5) / chord_size.to_f
      %>

      <% pcs.uniq.each do |pc| %>
        <%
          midi_note = base_midi + (pc % 12)
          freq = midi_to_freq.call(midi_note)
        %>
        [<%= current_time %>, ['/s_new', \polySynth, <%= node_id %>, 0, 0,
          \freq, <%= freq %>,
          \dur, <%= step_duration %>,
          \amp, <%= amp_each %>,
          \brightness, <%= bri %>,
          \hardness, <%= hrd %>,
          \texture, <%= tex %>,
          \resonance, 0.2
        ]],
        <%
          node_id += 1
        %>
      <% end %>
    <% end %>

    <%
      current_time += step_duration
    %>
  <% end %>
]);

a.recordNRT(
    outputFilePath: "<%= filepath %>",
    headerFormat: "wav",
    sampleFormat: "int16",
    options: server.options,
    duration: <%= total_duration + 2.0 %>, // 余韻
    action: { "done".postln }
);

server.remove;
