var server = Server(\nrt,
    options: ServerOptions.new
    .numOutputBusChannels_(2)
    .numInputBusChannels_(2)
);

<%
node_id = 1000
events = []

tracks.each do |track|
  time = 0.0
  tone = track[:tone] || 0
  harmRichness = track[:harmRichness] || 0
  brightness = track[:brightness] || 0
  noiseContent = track[:noiseContent] || 0
  formantChar = track[:formantChar] || 0
  inharmonicity = track[:inharmonicity] || 0
  resonance = track[:resonance] || 0

  track[:durations].each_with_index do |dur, idx|
    freq = midi_to_freq.call(track[:midiNoteNumbers][idx])
    dur  = dur * 0.125
    events << [time, node_id, freq, dur, harmRichness, brightness, noiseContent, formantChar, inharmonicity, resonance]
    time += dur
    node_id += 1
  end
end


groups = events.group_by { |t, _nid, _f, _d| t }
%>


a = Score([
  [0.0, ['/d_recv',
    // 6つの音色尺度を制御するSynthDef
    SynthDef(\multiTimbre, { |out=0, freq=440, dur=0.125,
        harmRichness=0.0,    // 尺度1: 倍音の豊かさ (0.0: 正弦波 → 1.0: 豊かな倍音)
        brightness=0.0,      // 尺度2: 高周波成分 (0.0: 暗い → 1.0: 明るい)
        noiseContent=0.0,    // 尺度3: ノイズ含有量 (0.0: 純音 → 1.0: ノイズ)
        formantChar=0.0,     // 尺度4: フォルマント特性 (0.0: なし → 1.0: 強いフォルマント)
        inharmonicity=0.0,   // 尺度5: 非整数倍音度 (0.0: 整数倍音 → 1.0: 非整数倍音)
        resonance=0.0        // 尺度6: 共鳴特性 (0.0: なし → 1.0: 強い共鳴)
    |
        var env, sig, base, formantFilter, inharmonics, resonanceSig;
        var nyquist, safeFreq, brightnessMult, hpfFreq, bpfFreq;

        // 定数として定義（サンプリング周波数44100Hzを想定）
        nyquist = 22050;

        // 安全な周波数範囲に制限
        safeFreq = freq.clip(20, 6600); // 約6.6kHz以下に制限

        // エンベロープ
        env = EnvGen.kr(Env([0, 1, 0.8, 0], [0.01, dur * 0.7, dur * 0.29]), doneAction: 2);

        // 基本波形の生成
        base = SelectX.ar(
            (harmRichness * 5).clip(0, 5),
            [
                SinOsc.ar(safeFreq) * 0.5,                                     // 純粋な正弦波
                Pulse.ar(safeFreq, 0.3 + (harmRichness * 0.4)) * 0.5,         // パルス波
                Saw.ar(safeFreq) * 0.5,                                        // ノコギリ波
                Mix.fill(4, { |i|
                    VarSaw.ar(safeFreq * (i+1), 0, 0.5, 1/(i+2))
                }) * 0.5,
                Mix.fill(6, { |i|
                    VarSaw.ar(safeFreq * (i+1), 0, 0.5, 1/(i+2))
                }) * 0.5,
                Blip.ar(safeFreq, 8) * 0.5
            ]
        );

        // 高周波成分の追加（条件文を避けてLinExpで調整）
        brightnessMult = brightness * freq.linexp(440, 7040, 1.0, 0.1); // 高音域ほど明るさを抑制
        hpfFreq = (safeFreq * 2).min(15000);
        bpfFreq = (safeFreq * 3).min(15000);

        sig = base + (HPF.ar(base, hpfFreq) * brightnessMult * 0.2);
        sig = sig + (BPF.ar(WhiteNoise.ar(0.03), bpfFreq, 0.8) * brightnessMult * 0.15);

        // ノイズの追加
        sig = (sig * (1 - noiseContent)) + (PinkNoise.ar(0.25) * noiseContent);

        // フォルマント特性の適用（条件文を使わずXFadeで）
        formantFilter = Formant.ar(
            safeFreq * 1.2,
            safeFreq * 2.2,
            safeFreq * 0.4
        ) * 0.15;
        sig = XFade2.ar(sig, formantFilter, formantChar * 2 - 1);

        // 非整数倍音の追加
        inharmonics = Mix.fill(3, { |i|
            var detune = 1.0 + (i * 0.06) + (LFNoise1.kr(0.3).range(-0.03, 0.03) * inharmonicity);
            var amp = 0.08 / (i + 1) * inharmonicity;
            SinOsc.ar(safeFreq * detune, 0, amp)
        });
        sig = sig + inharmonics;

        // 共鳴特性の適用
        resonanceSig = MoogFF.ar(sig, (safeFreq * (1 + (resonance * 4))).min(15000), resonance * 2.0);
        sig = XFade2.ar(sig, resonanceSig, resonance * 2 - 1);

        // 最終的な音量調整とソフトクリッピング
        sig = sig * 0.4;
        sig = sig.tanh;

        // 出力
        Out.ar(out, sig * env ! 2);
    }).asBytes;
  ]],
  <% groups.each do |time, evs| %>
    [
      <%= time %>,
      <% evs.each do |(_t, nid, freq, dur, harmRichness, brightness, noiseContent, formantChar, inharmonicity, resonance)| %>
        (x = Synth.basicNew(\multiTimbre, server, <%= nid %>))
          .newMsg(args: [
            freq: <%= freq %>,
            dur: <%= dur %>,
            harmRichness: <%=harmRichness %>,
            brightness: <%=brightness %>,
            noiseContent: <%=noiseContent %>,
            formantChar: <%=formantChar %>,
            inharmonicity: <%=inharmonicity %>,
            resonance: <%=resonance %>,
          ]),
      <% end %>
    ],
  <% end %>
]);

a.recordNRT(
    outputFilePath: "<%= filepath %>",
    headerFormat: "wav",
    sampleFormat: "int16",
    options: server.options,
    duration: <%= total_duration %>,
    action: { "done".postln }
);

server.remove;
